<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Icy Tower–style JS Game (Android + Phones)</title>
  <style>
    :root { --bg:#0f1226; --ui:#fff; }
    * { box-sizing: border-box; }
    html, body {
      height:100%; margin:0;
      background: radial-gradient(1200px 600px at 50% -10%, #1a1f49 0%, var(--bg) 60%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--ui);
      overflow:hidden;
    }
    canvas{ display:block; margin:auto; background:transparent; }
    #opts {
      position: fixed; top: 8px; right: 8px; width: 220px;
      background: rgba(0,0,0,.55); border:1px solid #ffffff22; border-radius:12px;
      padding:10px; font-size:12px; line-height:1.2; backdrop-filter: blur(6px);
      color:#fff; z-index: 5;
    }
    #opts .row { display:grid; grid-template-columns:1fr 120px; gap:6px; align-items:center; margin:6px 0; }
    #opts input[type="range"] { width:100%; }
    #opts .title { font-weight:600; margin-bottom:4px; font-size:13px; opacity:.9 }
  </style>
</head>
<body>
  <canvas id="game" width="900" height="800"></canvas>

  <div id="opts">
    <div class="title">Options</div>
    <div class="row"><label>Gravity</label><input id="gravity" type="range" min="0.1" max="1.2" step="0.01" value="0.41"></div>
    <div class="row"><label>Move speed</label><input id="moveSpeed" type="range" min="2" max="8" step="0.1" value="4.2"></div>
    <div class="row"><label>Jump force</label><input id="jumpForce" type="range" min="8" max="18" step="0.1" value="12.5"></div>
    <div class="row"><label>Camera speed</label><input id="camBase" type="range" min="0.4" max="2.0" step="0.05" value="1.0"></div>
    <div class="row"><label>Falling Phones</label><input id="fallingPhones" type="range" min="0" max="1" value="1"></div>
    <div class="row"><label>Mute Sounds</label><input id="muteSounds" type="range" min="0" max="1" value="0"></div>
  </div>
  <audio id="jumpSound" src="jumpSound.mp3"></audio>
<audio id="landSound" src="landSound.mp3"></audio>
<audio id="gameOverSound" src="gameOverSound.mp3"></audio>
<audio id="crashSound" src="crashSound.mp3"></audio>
<audio id="levelUpSound" src="levelUpSound.mp3"></audio>

  <script>
    let jumpSound = document.getElementById("jumpSound");
    let landSound = document.getElementById("landSound");
    let gameOverSound = document.getElementById("gameOverSound");
    let levelUpSound = document.getElementById("levelUpSound");
	
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Images
    const androidImg = new Image();
    androidImg.src = "https://upload.wikimedia.org/wikipedia/commons/d/d7/Android_robot.svg";
    const superAndroidImg = new Image(); // used during power mode
    superAndroidImg.src = "https://wallpapercave.com/wp/wp3720861.png";
    const iphoneImg = new Image();
    iphoneImg.src = "https://upload.wikimedia.org/wikipedia/commons/3/32/IPhone_X_vector.svg";

    // Input
    const KEYS = { left:false, right:false, jump:false, reset:false };
    let jumpWasDown = false;

    // Gate camera until first move
    let cameraStarted = false;

    addEventListener('keydown', e => {
      if (e.code==='ArrowLeft') KEYS.left = true;
      if (e.code==='ArrowRight') KEYS.right = true;
      if (e.code==='Space') KEYS.jump = true;
      if (e.code==='KeyR') KEYS.reset = true;

      if (!cameraStarted && (e.code === 'Space')) cameraStarted = true;
      if (['Space','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
    });
    addEventListener('keyup', e => {
      if (e.code==='ArrowLeft') KEYS.left = false;
      if (e.code==='ArrowRight') KEYS.right = false;
      if (e.code==='Space') KEYS.jump = false;
      if (e.code==='KeyR') KEYS.reset = false;
    });

    // World
    const world = {
      gravity: 0.4,
      moveSpeed: 3.2,
      jumpForce: 12.5,
      floorGap: 115,
      floorH: 15,
      themeSize: 100,
      camBase: 1.0,
      camPer100: 0.35,
    };
    let highestScore = 0;
    let highestFloor = 0;
    let floorNumber = 0;
    const themes = [ "#6cc2ff", "#ff82c6", "#64d964", "#ff9c40", "#5aa8ff" ];

    // Entities
    const player = {
      x: 220, y: 0, w: 50, h: 58, vx:0, vy:0,
      onGround:false, lastFloor:0,
      // sprint/rotation state
      sprintFrames: 0,           // how long left/right held
      sprintMult: 1,             // 1 → maxSprintMult
      rot: 0,                    // radians
      rotVel: 0,                 // radians per frame
      spinning: false            // spinning only on sprint jump
    };

    let floors = [];
    let phones = [];
    let powerOrbs = []; // green circles (rare)
    let score = 0;
    let cameraY = 0;
    let isGameOver = false;
    let fallingPhonesToggle = 1;
	let muteSoundsToggle = 0;

    // Jump charge
    let charging = false, chargeFrames = 0, maxChargeFrames = 15;
    let phoneSpawnTimer = 0;

    // Power Mode (Super Android)
    const POWER_DURATION_MS = 20000; // 20 seconds
    let powerActive = false;
    let powerEndTime = 0;
    let powerSpawnTimer = 0; // controls orb rarity

    // Sprint tuning
    const sprintThresholdFrames = 45;      // ~0.75s hold to hit max
    const maxSprintMult = 2.0;             // top speed multiplier
    const sprintDecay = 0.10;              // decay per frame when not holding

    // Stars (future background use-ready)
    const stars = [];
    function initStars(){
      stars.length = 0;
      for (let i=0;i<120;i++){
        stars.push({ x: Math.random()*canvas.width, y: -Math.random()*6000, z: 0.2 + Math.random()*0.8 });
      }
    }

    // Reset
    function resetGame() {
      floors = [];
      phones = [];
      powerOrbs = [];
      highestScore = score >= highestScore ? score : highestScore;
      highestFloor = floorNumber >= highestFloor ? floorNumber : highestFloor;
      score = 0;
      floorNumber = 0;
      cameraY = 0;
      isGameOver = false;
      player.lastFloor = 0;
      player.sprintFrames = 0; player.sprintMult = 1; player.rot = 0; player.rotVel = 0; player.spinning = false;

      cameraStarted = false;

      // base + initial floors
      floors.push({x:0, y:canvas.height-30, w:canvas.width, h:world.floorH, idx:0});
      for (let i=1;i<40;i++) addFloor(i);

      // place player
      player.x = canvas.width/2 - player.w/2;
      player.y = floors[0].y - player.h;
      player.vx = 0; player.vy = 0; player.onGround = true;

      // timers
      phoneSpawnTimer = 0;
      powerSpawnTimer = randInt(900, 1800); // ~15–30 seconds @60fps
      charging = false; chargeFrames = 0; jumpWasDown = false;

      // power reset
      powerActive = false;
      powerEndTime = 0;

      initStars();
    }

    function addFloor(i){
      const maxW = canvas.width * 0.50;
      const minW = canvas.width * 0.30;
      const w = rand(minW, maxW);
      const x = rand(12, canvas.width - w - 12);
      const y = floors[0].y - i * world.floorGap;
      floors.push({x, y, w, h:world.floorH, idx:i});
    }

    function themeForFloor(idx){
      const t = Math.floor(idx / world.themeSize) % themes.length;
      return themes[t];
    }

    function rand(a,b){ return Math.random()*(b-a)+a; }
    function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

    function step() {
      if (isGameOver){
        if (KEYS.reset) resetGame();
        return;
      }

      // --- Sprint charge from long-press left/right
      const holdingDir = (KEYS.left ^ KEYS.right); // true if exactly one is held
      if (holdingDir) {
        player.sprintFrames = Math.min(player.sprintFrames + 1, sprintThresholdFrames);
      } else {
        player.sprintFrames = Math.max(0, player.sprintFrames - sprintThresholdFrames * sprintDecay);
      }
      // map frames → multiplier [1 .. maxSprintMult]
      const sprintRatio = player.sprintFrames / sprintThresholdFrames;
      player.sprintMult = 1 + (maxSprintMult - 1) * Math.max(0, Math.min(1, sprintRatio));

      // Controls → velocity (use sprint multiplier)
      player.vx = 0;
      if (KEYS.left)  player.vx -= world.moveSpeed * player.sprintMult;
      if (KEYS.right) player.vx += world.moveSpeed * player.sprintMult;

      // --- Charged jump (add sprint bonus to jump)
      if (player.onGround && KEYS.jump){
	      if(!muteSoundsToggle) document.getElementById("jumpSound").play();

        charging = true;
        if (chargeFrames < maxChargeFrames) chargeFrames++;
      }
      if (charging && (!KEYS.jump || chargeFrames >= maxChargeFrames)){
        const basePart = world.jumpForce * 0.65;
        const holdBonus = (chargeFrames / maxChargeFrames) * world.jumpForce * 0.65;
        const sprintJumpBonus = (player.sprintMult - 1) * 6.5; // extra from running
        player.vy = -(basePart + holdBonus + sprintJumpBonus);

        // Start spin ONLY if sprint added noticeable bonus
        if (sprintJumpBonus > 1.5) {
          player.spinning = true;
          // spin faster with more sideways speed; direction matches move dir
          const dir = Math.sign(player.vx || (KEYS.right ? 1 : -1));
          player.rotVel = dir * (0.10 + 0.08 * (player.sprintMult - 1)); // rad/frame
        } else {
          player.spinning = false;
          player.rotVel = 0;
          player.rot = 0;
        }

        player.onGround = false;
        charging = false; chargeFrames = 0;
      }
      jumpWasDown = KEYS.jump;

      // Physics
      player.vy += world.gravity;
      player.x += player.vx;
      player.y += player.vy;

      // Update spin while airborne; stop when grounded
      if (!player.onGround && player.spinning) {
        player.rot += player.rotVel;
      } else if (player.onGround) {
        player.rot = 0;
        player.rotVel = 0;
        player.spinning = false;	
		
      }

      // Wall bounce
      if (player.x < 0) { player.x = 0; player.vx = 100.5; }
      if (player.x + player.w > canvas.width) { player.x = canvas.width - player.w; player.vx = -100.5; }

      // Camera (only after first move)
      const camSpeed = world.camBase + Math.floor(player.lastFloor / 100) * world.camPer100;
      if (cameraStarted) {
        cameraY -= camSpeed;
        const headroom = 180;
        if (player.y - cameraY < headroom) cameraY = player.y - headroom;
      }

      // Generate more floors above
      const topNeededIdx = Math.floor((floors[0].y - cameraY) / world.floorGap) + 70;
      while (floors.length <= topNeededIdx) addFloor(floors.length);

      // Floor collisions & scoring
      player.onGround = false;
      for (let i=0;i<floors.length;i++){
        const f = floors[i];
        if (player.vy >= 0 &&
            player.x + player.w*0.8 > f.x &&
            player.x + player.w*0.2 < f.x + f.w){
          const feetPrev = player.y - player.vy + player.h;
          const feetNow  = player.y + player.h;
          if (feetPrev <= f.y && feetNow >= f.y){
            player.y = f.y - player.h;
            player.vy = 0;
            player.onGround = true;
			

            // stop spin on landing
            player.rot = 0; player.rotVel = 0; player.spinning = false;

            const climbed = f.idx - player.lastFloor;
            if (climbed > 0){
              floorNumber += climbed;
              highestScore = score >= highestScore ? score : highestScore;
              highestFloor = floorNumber >= highestFloor ? floorNumber : highestFloor;
              score += (climbed === 1) ? 1 : (climbed * climbed);
              player.lastFloor = f.idx;
            }
          }
        }
      }

      // Spawn phones
      if ((player.lastFloor >= Math.random() * 100) && fallingPhonesToggle === 1){
        const tier = Math.floor((player.lastFloor - 50) / 100);
        const baseInterval = 85;
        const minInterval  = 25;
        const interval = Math.max(minInterval, baseInterval - tier*12);
        phoneSpawnTimer--;
        if (phoneSpawnTimer <= 0){
          spawnPhone(tier);
          phoneSpawnTimer = interval;
        }
      }
      updatePhones();

      // Spawn power orbs (rare)
      if (!powerActive && powerOrbs.length === 0) {
        powerSpawnTimer--;
        if (powerSpawnTimer <= 0) {
          spawnPowerOrb();
          powerSpawnTimer = randInt(1200, 2400);
        }
      }
      updatePowerOrbs();

      // Power mode expiration
      if (powerActive && performance.now() >= powerEndTime) {
        powerActive = false;
      }

      // Fail (falls far below camera)
      if (player.y - cameraY > canvas.height + 40){ setGameOver(); }
    }

    // Phones
    function spawnPhone(tier){
      const w = 34, h = 68;
      const x = Math.random() * (canvas.width - w);
      const y = cameraY - h - 20; // just above current camera view
      const vy = 3 + tier*1.4 + Math.random()*0.6;
      phones.push({x,y,w,h,vy});
    }

    function updatePhones(){
      for (let i=phones.length-1;i>=0;i--){
        const p = phones[i];
        p.y += p.vy;

        const overlap = !(p.x + p.w < player.x || p.x > player.x + player.w ||
                          p.y + p.h < player.y || p.y > player.y + player.h);

        if (overlap){
          if (powerActive) {
            score += 1000;
            phones.splice(i,1);
            continue;
          } else {
            setGameOver();
            return;
          }
        }

        if (p.y - cameraY > canvas.height + 120) phones.splice(i,1);
      }
    }

    // Power Orbs
    function spawnPowerOrb(){
      const r = 12;
      const x = r + Math.random() * (canvas.width - r*2);
      const y = cameraY - r - 30;
      const vy = 2.2 + Math.random()*0.8;
      powerOrbs.push({x, y, r, vy});
    }

    function updatePowerOrbs(){
      for (let i=powerOrbs.length-1;i>=0;i--){
        const o = powerOrbs[i];
        o.y += o.vy;

        const left = o.x - o.r, right = o.x + o.r, top = o.y - o.r, bottom = o.y + o.r;
        const overlap = !(right < player.x || left > player.x + player.w ||
                          bottom < player.y || top > player.y + player.h);
        if (overlap){
          powerActive = true;
		  if(!muteSoundsToggle) document.getElementById("levelUpSound").play();

          powerEndTime = performance.now() + POWER_DURATION_MS;
          powerOrbs.splice(i,1);
          continue;
        }

        if (o.y - cameraY > canvas.height + 120) powerOrbs.splice(i,1);
      }
    }

    function setGameOver(){
	if(!muteSoundsToggle) document.getElementById("crashSound").play();

	isGameOver = true;
	}

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);

      ctx.save();
      ctx.translate(0, -cameraY);

      // Floors
      for (const f of floors){
        const color = f.idx === 0 ? "#64d964" : themeForFloor(f.idx);
        ctx.fillStyle = color;
        ctx.fillRect(f.x, f.y, f.w, f.h);
        if (f.idx % 10 === 0){
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = "#fff";
          ctx.font = "30px ui-monospace, monospace";
          ctx.fillText(f.idx, f.x + (f.w / 2), f.y + 40);
          ctx.globalAlpha = 1;
        }
      }

      // Phones
      for (const p of phones){
        if (iphoneImg.complete) ctx.drawImage(iphoneImg, p.x, p.y, p.w, p.h);
        else { ctx.fillStyle = "#111"; roundRect(p.x, p.y, p.w, p.h, 8, true); }
      }

      // Power Orbs
      for (const o of powerOrbs){
        const grd = ctx.createRadialGradient(o.x, o.y, 2, o.x, o.y, o.r+6);
        grd.addColorStop(0, 'rgba(100, 255, 140, 0.95)');
        grd.addColorStop(1, 'rgba(60, 200, 90, 0.1)');
        ctx.fillStyle = grd;
        ctx.beginPath(); ctx.arc(o.x, o.y, o.r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = 'rgba(80, 230, 110, 0.9)'; ctx.lineWidth = 2; ctx.stroke();
      }

      // Player (supports rotation during sprint jumps)
      const useSuper = powerActive && superAndroidImg.complete;
      const img = useSuper ? superAndroidImg : androidImg;
      const cx = player.x + player.w/2;
      const cy = player.y + player.h/2;

      ctx.save();
      if (!player.onGround && player.spinning) {
        ctx.translate(cx, cy);
        ctx.rotate(player.rot);
        ctx.translate(-cx, -cy);
      }
      if (img.complete) {
        if (powerActive){
          ctx.save();
          ctx.globalAlpha = 0.45;
          ctx.fillStyle = '#4aff8a';
          ctx.beginPath();
          ctx.ellipse(player.x + player.w/2, player.y + player.h*0.9, player.w*0.6, 10, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
        ctx.drawImage(img, player.x, player.y, player.w, player.h);
      } else {
        ctx.fillStyle = powerActive ? "#45ff82" : "#A4C639";
        roundRect(player.x, player.y, player.w, player.h, 8, true);
      }
      ctx.restore();

      ctx.restore();

      // HUD
      ctx.fillStyle = "#fff";
      ctx.font = "16px system-ui, sans-serif";
      ctx.fillText(
        "Score: " + score +
        "   Floor: " + floorNumber +
        "   Highest score: " + highestScore +
        "   Highest Floor: " + highestFloor,
        0, 22
      );

      // Power timer HUD
      if (powerActive){
        const msLeft = Math.max(0, powerEndTime - performance.now());
        const sLeft = Math.ceil(msLeft / 1000);
        ctx.fillStyle = "#4aff8a";
        ctx.font = "18px system-ui, sans-serif";
        ctx.fillText("POWER: " + sLeft + "s", canvas.width - 140, 22);
      }

      // Copyright
      ctx.fillStyle = "#fff";
      ctx.font = "16px system-ui, sans-serif";
      ctx.fillText("Prompted by Peter Sameh", 0, canvas.height);

      if (isGameOver){
		//document.getElementById("gameOverSound").play;

        ctx.fillStyle = "rgba(0,0,0,.55)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 32px system-ui, sans-serif";
        ctx.textAlign = "center";
        const msg = "\"You're cooked🍎\" \n";
        ctx.fillText(msg, canvas.width/2, canvas.height/2 - 10);
        ctx.font = "24px system-ui, sans-serif";
        ctx.fillText("~Tim Cook", canvas.width/2, canvas.height/2 + 20);
        ctx.font = "16px system-ui, sans-serif";
        ctx.fillText("Press R to Restart", canvas.width/2, canvas.height/2 + 50);
        ctx.textAlign = "start";
      }
    }

    function roundRect(x,y,w,h,r,fill){
      const rr = Math.min(r, w*0.5, h*0.5);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y, x+w,y+h, rr);
      ctx.arcTo(x+w,y+h, x,y+h, rr);
      ctx.arcTo(x,y+h, x,y, rr);
      ctx.arcTo(x,y, x+w,y, rr);
      if (fill){ ctx.fill(); } else { ctx.stroke(); }
    }

    function loop(){
      step();
      draw();
      requestAnimationFrame(loop);
    }

    // Options wiring
    const gravityEl = document.getElementById('gravity');
    const moveEl = document.getElementById('moveSpeed');
    const jumpEl = document.getElementById('jumpForce');
    const camEl = document.getElementById('camBase');
    const fallingPhonesEnabled = document.getElementById('fallingPhones');
	const muteSoundsEnabled = document.getElementById('muteSounds');

    gravityEl.addEventListener('input', ()=> world.gravity = +gravityEl.value);
    moveEl.addEventListener('input',   ()=> world.moveSpeed = +moveEl.value);
    jumpEl.addEventListener('input',   ()=> world.jumpForce = +jumpEl.value);
    camEl.addEventListener('input',    ()=> world.camBase   = +camEl.value);
    fallingPhonesEnabled.addEventListener('input', ()=> fallingPhonesToggle = +fallingPhonesEnabled.value);
	muteSoundsEnabled.addEventListener('input', ()=> muteSoundsToggle = +muteSoundsEnabled.value);

    resetGame();
    loop();
  </script>
</body>
</html>
